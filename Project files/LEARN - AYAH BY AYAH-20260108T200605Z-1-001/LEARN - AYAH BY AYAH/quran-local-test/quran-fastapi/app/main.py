from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pathlib import Path
import json

app = FastAPI(title="Quran Local Test API (Surahs 112–114)", version="0.1.0")

# allow local UI (and later designers' tools)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------- paths ----------
HERE = Path(__file__).resolve().parent          # .../app
ROOT = HERE.parent                              # .../quran-fastapi
DATA_DIR = ROOT / "data"
WEB_DIR = ROOT / "web"

# ✅ use the *small* JSONs generated by tools/make_last3_surahs.py
LEXICON_PATH = DATA_DIR / "lexicon_112_114.json"
AYAH_INDEX_PATH = DATA_DIR / "ayah_index_112_114.json"


def load_json(p: Path):
    if not p.exists():
        raise FileNotFoundError(f"Missing file: {p}")
    return json.loads(p.read_text(encoding="utf-8"))


# load once on startup
try:
    print("✅ Loading lexicon from:", LEXICON_PATH)
    print("✅ Loading ayah index from:", AYAH_INDEX_PATH)
    lexicon = load_json(LEXICON_PATH)
    ayah_index = load_json(AYAH_INDEX_PATH)
    print("✅ lexicon rows:", len(lexicon))
    print("✅ ayah_index keys:", len(ayah_index))
except Exception as e:
    lexicon = []
    ayah_index = {}
    print("❌ Startup load failed:", e)


# ---------- Build ayah sequencing map ----------
def build_ayahs_by_surah(rows):
    m = {}
    for r in rows:
        try:
            s = int(r.get("surah", 0))
            a = int(r.get("ayah", 0))
        except Exception:
            continue
        if s <= 0 or a <= 0:
            continue
        if s not in m:
            m[s] = set()
        m[s].add(a)
    return {s: sorted(list(ayahs)) for s, ayahs in m.items()}


ayahs_by_surah = build_ayahs_by_surah(lexicon)


# ---------- API ----------
@app.get("/health")
def health():
    return {
        "ok": True,
        "mode": "112-114 only",
        "lexicon_rows": len(lexicon),
        "ayah_index_keys": len(ayah_index),
        "surahs_loaded": sorted(list(ayahs_by_surah.keys())),
    }


@app.get("/api/lexicon")
def api_lexicon():
    return lexicon


@app.get("/api/ayah_index")
def api_ayah_index():
    return ayah_index


@app.get("/api/ayah/{surah}/{ayah}")
def api_get_ayah(surah: int, ayah: int):
    # guard: only allow 112..114 in this scaled mode
    if surah < 112 or surah > 114:
        raise HTTPException(
            status_code=400,
            detail="This API is currently limited to Surahs 112–114."
        )

    words = [
        r for r in lexicon
        if int(r.get("surah", 0)) == surah and int(r.get("ayah", 0)) == ayah
    ]
    words.sort(key=lambda r: int(r.get("word", 0)))

    if not words:
        raise HTTPException(
            status_code=404,
            detail="Ayah not found in lexicon (112–114 dataset)."
        )

    arabic = " ".join(w.get("arabic", "") for w in words).strip()
    english = " ".join(w.get("english", "") for w in words).strip()

    key = f"{surah}:{ayah}"
    raw = ayah_index.get(key)

    # normalize audio URL under /static/ayahs_wav
    audio_url = None
    if raw:
        # raw can be a string OR dict like {"path": "..."}
        raw_path = raw.get("path") if isinstance(raw, dict) else raw
        p = str(raw_path).replace("\\", "/")
        idx = p.find("ayahs_wav/")
        if idx >= 0:
            p = p[idx:]  # ayahs_wav/...
            audio_url = f"/static/{p}"

    return {
        "surah": surah,
        "ayah": ayah,
        "arabic": arabic,
        "english": english,
        "words": words,
        "audio_url": audio_url,
        "audio_path_raw": raw,
    }


@app.get("/api/next")
def api_next(surah: int, ayah: int):
    """
    Returns the next (surah, ayah) based on lexicon ordering.
    Only valid for surahs 112..114 in this dataset.
    """
    if surah < 112 or surah > 114:
        raise HTTPException(status_code=400, detail="This API is limited to Surahs 112–114.")

    if surah not in ayahs_by_surah:
        raise HTTPException(status_code=404, detail="Surah not found in lexicon")

    lst = ayahs_by_surah[surah]
    if ayah not in lst:
        raise HTTPException(status_code=404, detail="Ayah not found in this surah")

    i = lst.index(ayah)

    # next ayah in same surah
    if i < len(lst) - 1:
        return {"surah": surah, "ayah": lst[i + 1], "surah_changed": False, "end": False}

    # move to next surah available (112..114 only)
    s = surah + 1
    while s <= 114:
        if s in ayahs_by_surah and len(ayahs_by_surah[s]) > 0:
            return {"surah": s, "ayah": ayahs_by_surah[s][0], "surah_changed": True, "end": False}
        s += 1

    return {"surah": None, "ayah": None, "surah_changed": True, "end": True}


# ---------- Static hosting ----------
# UI folder
app.mount("/web", StaticFiles(directory=WEB_DIR, html=True), name="web")

# audio folders (junctions are inside ROOT)
app.mount(
    "/static/ayahs_wav",
    StaticFiles(directory=ROOT / "ayahs_wav", follow_symlink=True),
    name="ayahs_wav",
)

# (optional) only mount if you actually have it; safe-guard it
WORDS_DIR = ROOT / "words_wav"
if WORDS_DIR.exists():
    app.mount(
        "/static/words_wav",
        StaticFiles(directory=WORDS_DIR, follow_symlink=True),
        name="words_wav",
    )


# open UI on /
@app.get("/")
def root_ui():
    return FileResponse(WEB_DIR / "index.html")
